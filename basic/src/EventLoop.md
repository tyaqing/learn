# 事件循环模型 EventLoop

## 执行栈与任务队列

单线程的 JavaScript 一段一段地执行，前面的执行完了，再执行后面的，试想一个，如果前一个任务需要执行很久，比如接口请求、I/O 操作，此时后面的任务只能干巴巴地等待么？干等不仅浪费了资源，而且页面的交互程度也很差。JavaScript 意识到了这个问题，他们将任务分成了同步任务和异步任务，对于二者有不同的处理。

JavaScript 在运行时会将变量存放在堆（heap）和栈（stack）中，堆中通常存放着一些对象，而变量及对象的指针则存放在栈中。JavaScript 在执行时，同步任务会排好队，在主线程上按照顺序执行，前面的执行完了再执行后面的，排队的地方叫执行栈（execution context stack）。JavaScript 对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果时，异步任务会加入与执行栈不一样的队列，即任务队列（task queue），所以任务队列中存放的是异步任务执行完成后的结果，通常是回调函数。

当执行栈的同步任务已经执行完成，此时主线程闲下来，它便会去查看任务队列是否有任务，如果有，主线程会将最先进入任务队列的任务加入到执行栈中执行，执行栈中的任务执行完了之后，主线程便又去任务队列中查看是否有任务可执行。主线程去任务队列读取任务到执行栈中去执行，这个过程是循环往复的，这便是 Event Loop，事件循环。
网上有张流传甚广的图对这一过程进行了总结，在图中我们可以看到，JavaScript 在运行时产生了堆和栈，ajax、setTimeout 等异步任务被挂起，异步任务的返回结果加入任务队列，主线程会循环往复地读取任务队列中的任务，加入执行栈中执行。

![tupian](eventloop.png)

## 模型的流转运行

- 执行初始化代码
- 将事件回调函数交给对应模块管理
- 当事件发生时,管理模块会将回调函数以及其数据加入循环队列
- 只有当初始化代码执行完成后才会遍历循环队列中的回调函数

## 循环模型的 2 个重要组成部分

事件管理模块(DOM 事件,定时器,Ajax)
回调队列

## callback queue

包含

- 任务队列
- 事件队列
- 消息队列

## event loop 事件轮询

从任务队列中循环取出回调函数到执行栈中去处理

setTimeOut 是在时间完成之后才加入到回调队列中去的

## 宏任务与微任务

常见宏任务:script(整体代码),setTimeout,setInterval;
常见微任务:new Promise,process.nextTick(node.js 环境)

### 执行顺序

- 最开始执行 script 整体代码
- 下面的任务将循环执行
  1. 选择最先进入执行栈的宏任务执行
  2. 检查是否有微任务,如果存在,则执行微任务直至清空
  3. 重复以上步骤
